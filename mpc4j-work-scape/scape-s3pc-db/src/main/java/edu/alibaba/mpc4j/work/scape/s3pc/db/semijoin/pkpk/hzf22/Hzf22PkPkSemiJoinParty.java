package edu.alibaba.mpc4j.work.scape.s3pc.db.semijoin.pkpk.hzf22;

import com.google.common.base.Preconditions;
import edu.alibaba.mpc4j.common.circuit.z2.Z2CircuitConfig;
import edu.alibaba.mpc4j.common.circuit.z2.Z2IntegerCircuit;
import edu.alibaba.mpc4j.common.circuit.z2.comparator.ComparatorFactory;
import edu.alibaba.mpc4j.common.circuit.z2.comparator.ComparatorFactory.ComparatorType;
import edu.alibaba.mpc4j.common.circuit.z2.utils.Z2VectorUtils;
import edu.alibaba.mpc4j.common.rpc.MpcAbortException;
import edu.alibaba.mpc4j.common.rpc.Party;
import edu.alibaba.mpc4j.common.rpc.PtoState;
import edu.alibaba.mpc4j.common.structure.database.ZlDatabase;
import edu.alibaba.mpc4j.common.tool.MathPreconditions;
import edu.alibaba.mpc4j.common.tool.bitvector.BitVector;
import edu.alibaba.mpc4j.common.tool.bitvector.BitVectorFactory;
import edu.alibaba.mpc4j.common.tool.utils.LongUtils;
import edu.alibaba.mpc4j.s3pc.abb3.basic.Abb3Party;
import edu.alibaba.mpc4j.s3pc.abb3.basic.shuffle.ShuffleOperations.ShuffleOp;
import edu.alibaba.mpc4j.s3pc.abb3.basic.utils.ShuffleUtils;
import edu.alibaba.mpc4j.s3pc.abb3.structure.z2.TripletZ2Vector;
import edu.alibaba.mpc4j.work.scape.s3pc.db.join.pkpk.PkPkJoinFactory;
import edu.alibaba.mpc4j.work.scape.s3pc.db.join.pkpk.PkPkJoinFnParam;
import edu.alibaba.mpc4j.work.scape.s3pc.db.join.pkpk.PkPkJoinParty;
import edu.alibaba.mpc4j.work.scape.s3pc.db.join.pkpk.hzf22.Hzf22PkPkJoinConfig;
import edu.alibaba.mpc4j.work.scape.s3pc.db.join.pkpk.hzf22.Hzf22PkPkJoinPtoDesc;
import edu.alibaba.mpc4j.work.scape.s3pc.db.semijoin.pkpk.AbstractPkPkSemiJoinParty;
import edu.alibaba.mpc4j.work.scape.s3pc.db.semijoin.SemiJoinFnParam;
import edu.alibaba.mpc4j.work.scape.s3pc.db.semijoin.pkpk.PkPkSemiJoinParty;
import edu.alibaba.mpc4j.work.scape.s3pc.db.tools.SortUtils;
import edu.alibaba.mpc4j.work.scape.s3pc.db.tools.randenc.RandomEncodingFactory;
import edu.alibaba.mpc4j.work.scape.s3pc.db.tools.randenc.RandomEncodingFnParam;
import edu.alibaba.mpc4j.work.scape.s3pc.db.tools.randenc.RandomEncodingParty;
import edu.alibaba.mpc4j.work.scape.s3pc.db.tools.randenc.mrr20.Mrr20RandomEncodingConfig;
import edu.alibaba.mpc4j.work.scape.s3pc.opf.merge.MergeFactory;
import edu.alibaba.mpc4j.work.scape.s3pc.opf.merge.MergeFnParam;
import edu.alibaba.mpc4j.work.scape.s3pc.opf.merge.MergeParty;
import edu.alibaba.mpc4j.work.scape.s3pc.opf.permutation.PermuteFactory;
import edu.alibaba.mpc4j.work.scape.s3pc.opf.permutation.PermuteOperations.PermuteFnParam;
import edu.alibaba.mpc4j.work.scape.s3pc.opf.permutation.PermuteOperations.PermuteOp;
import edu.alibaba.mpc4j.work.scape.s3pc.opf.permutation.PermuteParty;
import gnu.trove.list.linked.TLongLinkedList;

import java.math.BigInteger;
import java.util.Arrays;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.stream.IntStream;

/**
 * HZF22 PkPk semi join party
 *
 * @author Feng Han
 * @date 2025/2/25
 */
public class Hzf22PkPkSemiJoinParty extends AbstractPkPkSemiJoinParty implements PkPkSemiJoinParty {
    /**
     * adder type
     */
    public final ComparatorType comparatorType;
    /**
     * z2 circuit
     */
    protected final Z2IntegerCircuit z2IntegerCircuit;
    /**
     * permute party
     */
    protected final PkPkJoinParty joinParty;
    /**
     * permute party
     */
    protected final PermuteParty permuteParty;
    /**
     * random encoding party
     */
    protected final RandomEncodingParty encodingParty;
    /**
     * soprp party
     */
    protected final MergeParty mergeParty;
    /**
     * party to permute the left table
     */
    private final Party leftPermuteParty = rpc.getParty(0);
    /**
     * party to permute the right table
     */
    private final Party rigthPermuteParty = rpc.getParty(1);
    /**
     * aider party
     */
    private final Party aiderParty = rpc.getParty(2);
    /**
     * the permutation generated by the left party
     */
    private int[] perm4LeftKey;
    /**
     * the permutation generated by the right party
     */
    private int[] perm4RightKey;

    public Hzf22PkPkSemiJoinParty(Abb3Party abb3Party, Hzf22PkPkSemiJoinConfig config) {
        super(Hzf22PkPkJoinPtoDesc.getInstance(), abb3Party, config);
        comparatorType = config.getJoinConfig().getComparatorTypes();
        z2IntegerCircuit = new Z2IntegerCircuit(z2cParty, new Z2CircuitConfig.Builder().setComparatorType(comparatorType).build());
        Hzf22PkPkJoinConfig pkPkJoinConfig = config.getJoinConfig();
        joinParty = PkPkJoinFactory.createParty(abb3Party, pkPkJoinConfig);
        permuteParty = PermuteFactory.createParty(abb3Party, pkPkJoinConfig.getPermuteConfig());
        encodingParty = RandomEncodingFactory.createParty(abb3Party, pkPkJoinConfig.getEncodingConfig());
        mergeParty = MergeFactory.createParty(abb3Party, pkPkJoinConfig.getMergeConfig());
        addMultiSubPto(joinParty, permuteParty, encodingParty, mergeParty);
    }

    @Override
    public void init() throws MpcAbortException {
        logPhaseInfo(PtoState.INIT_BEGIN);

        stopWatch.start();
        joinParty.init();
        permuteParty.init();
        encodingParty.init();
        mergeParty.init();
        abb3Party.init();
        initState();
        logStepInfo(PtoState.INIT_STEP, 1, 1, resetAndGetTime());

        logPhaseInfo(PtoState.INIT_END);
    }

    @Override
    public long[] setUsage(SemiJoinFnParam... params) {
        long[] tuples = new long[]{0, 0};
        if (isMalicious) {
            for (SemiJoinFnParam param : params) {
                if (param.isInputSorted) {
                    long[] tmp = joinParty.setUsage(
                        new PkPkJoinFnParam(param.leftDataNum, param.rightDataNum, param.keyDim, 0, 0, true));
                    tuples[0] += tmp[0];
                    tuples[1] += tmp[1];
                } else {
                    int totalNum = param.leftDataNum + param.rightDataNum;
                    int indexDim = LongUtils.ceilLog2(totalNum);
                    TLongLinkedList notSet = new TLongLinkedList();
                    // circuit
                    if (withDummy) {
                        notSet.add(2L * totalNum);
                    }
                    long eq = (long) Mrr20RandomEncodingConfig.THRESHOLD_REDUCE * totalNum;
                    long leq = 2L * ComparatorFactory.getAndGateNum(comparatorType, Mrr20RandomEncodingConfig.THRESHOLD_REDUCE) * totalNum;
                    notSet.add(eq + leq);
                    // switch network
                    long permuteLeft = abb3Party.getShuffleParty().getTupleNum(ShuffleOp.B_PERMUTE_NETWORK, param.leftDataNum, param.leftDataNum, Mrr20RandomEncodingConfig.THRESHOLD_REDUCE);
                    long permuteRight = 2L * abb3Party.getShuffleParty().getTupleNum(ShuffleOp.B_PERMUTE_NETWORK, param.rightDataNum, param.rightDataNum, Mrr20RandomEncodingConfig.THRESHOLD_REDUCE);
                    notSet.add(permuteLeft + permuteRight);
                    long noSetAll = notSet.sum();
                    abb3Party.updateNum(noSetAll, 0);

                    long[] mergeTuple = mergeParty.setUsage(new MergeFnParam(param.leftDataNum, param.rightDataNum, Mrr20RandomEncodingConfig.THRESHOLD_REDUCE + indexDim + 2));
                    long[] permuteTuple = permuteParty.setUsage(new PermuteFnParam(PermuteOp.APPLY_INV_B_B, param.rightDataNum, 1, indexDim));
                    long[] encodingTuple = encodingParty.setUsage(new RandomEncodingFnParam(param.keyDim, param.leftDataNum, param.rightDataNum, true));
                    tuples[0] += mergeTuple[0] + permuteTuple[0] + encodingTuple[0] + noSetAll;
                    tuples[1] += mergeTuple[1] + permuteTuple[1] + encodingTuple[1];
                }
            }
        }
        return tuples;
    }

    @Override
    public TripletZ2Vector semiJoin(TripletZ2Vector[] x, TripletZ2Vector[] y, int[] xKeyIndex, int[] yKeyIndex, boolean withDummy, boolean inputIsSorted) throws MpcAbortException {
        inputProcess(x, y, xKeyIndex, yKeyIndex, withDummy, inputIsSorted);
        if (inputIsSorted) {
            int[] keyDims = IntStream.range(0, xKeyIndex.length).toArray();
            TripletZ2Vector[] res = joinParty.primaryKeyInnerJoin(newLeft, newRight, keyDims, keyDims, withDummy, inputIsSorted);
            return res[res.length - 1];
        } else {
            logPhaseInfo(PtoState.PTO_BEGIN, "semiJoin");

            stopWatch.start();
            TripletZ2Vector[][] encoding = encodingParty.getEncodingForTwoKeys(
                Arrays.copyOf(newLeft, keyDim), newLeft[newLeft.length - 1],
                Arrays.copyOf(newRight, keyDim), newRight[newRight.length - 1], withDummy);
            int encKeyLen = encoding[0].length;
            logStepInfo(PtoState.PTO_STEP, 1, 5, resetAndGetTime(), "encoding");

            stopWatch.start();
            // 1. 得到需要Merge的input
            TripletZ2Vector[][] mergeKey = getSortInput(encoding);
            logStepInfo(PtoState.PTO_STEP, 2, 5, resetAndGetTime(), "get merge input");

            stopWatch.start();
            // 2. merge
            TripletZ2Vector[] mergeRes = mergeTables(mergeKey[0], mergeKey[1]);
            logStepInfo(PtoState.PTO_STEP, 3, 5, resetAndGetTime(), "merge");

            stopWatch.start();
            // 3. get the equal flag and permute the payload of left table
            TripletZ2Vector eqFlag = getEqFlag4RightTab(mergeRes, encKeyLen);
            logStepInfo(PtoState.PTO_STEP, 4, 5, resetAndGetTime(), "get equalFlag");

            stopWatch.start();
            // 4. shuffle the result to the original right table
            TripletZ2Vector[] permInput = isMalicious ? new TripletZ2Vector[encKeyLen + 1] : new TripletZ2Vector[1];
            permInput[0] = eqFlag;
            if (isMalicious) {
                System.arraycopy(mergeKey[1], 0, permInput, 1, encKeyLen);
            }
            int[] invPerm4RightKey = perm4RightKey == null ? null : ShuffleUtils.invOfPermutation(perm4RightKey);
            permInput = (TripletZ2Vector[]) abb3Party.getShuffleParty().permuteNetwork(
                permInput, invPerm4RightKey, permInput[0].bitNum(), rigthPermuteParty, leftPermuteParty, aiderParty);
            if (isMalicious) {
                TripletZ2Vector[] xorRes = z2cParty.xor(encoding[1], Arrays.copyOfRange(permInput, 1, permInput.length));
                z2cParty.compareView4Zero(xorRes);
            }
            logStepInfo(PtoState.PTO_STEP, 5, 5, resetAndGetTime(), "permute equal flag into the correct position");

            logPhaseInfo(PtoState.PTO_END, "primaryKeyInnerJoin");
            return permInput[0];
        }
    }

    /**
     * if inputIsSorted: sort the input keys directly
     * else: randomized encoding the input keys, and use them as the sorting input
     *
     * @return leftSortInput, rightSortInput
     */
    protected TripletZ2Vector[][] getSortInput(TripletZ2Vector[][] encoding) throws MpcAbortException {
        int encDim = encoding[0].length;
        // two party generate permutations
        if (abb3Party.ownParty().equals(leftPermuteParty)) {
            BitVector[] leftEncPlain = z2cParty.revealOwn(encoding[0]);
            z2cParty.revealOther(encoding[1], rigthPermuteParty);
            perm4LeftKey = getPermutation(leftEncPlain);
        } else if (abb3Party.ownParty().equals(rigthPermuteParty)) {
            z2cParty.revealOther(encoding[0], leftPermuteParty);
            BitVector[] rightEncPlain = z2cParty.revealOwn(encoding[1]);
            perm4RightKey = getPermutation(rightEncPlain);
        } else {
            z2cParty.revealOther(encoding[0], leftPermuteParty);
            z2cParty.revealOther(encoding[1], rigthPermuteParty);
        }
        // permute the encoding and validFlag
        int validFlagLen = withDummy ? 1 : 0;
        TripletZ2Vector[] permInputLeft = new TripletZ2Vector[validFlagLen + encDim];
        System.arraycopy(encoding[0], 0, permInputLeft, 0, encDim);
        TripletZ2Vector[] permInputRight = new TripletZ2Vector[validFlagLen + encDim];
        System.arraycopy(encoding[1], 0, permInputRight, 0, encDim);
        if (withDummy) {
            permInputLeft[encDim] = newLeft[newLeft.length - 1];
            permInputRight[encDim] = newRight[newRight.length - 1];
        }
        permInputLeft = (TripletZ2Vector[]) abb3Party.getShuffleParty().permuteNetwork(
            permInputLeft, perm4LeftKey, permInputLeft[0].bitNum(), leftPermuteParty, rigthPermuteParty, aiderParty);
        permInputRight = (TripletZ2Vector[]) abb3Party.getShuffleParty().permuteNetwork(
            permInputRight, perm4RightKey, permInputRight[0].bitNum(), rigthPermuteParty, leftPermuteParty, aiderParty);
        TripletZ2Vector[] sortedLeftEnc = Arrays.copyOfRange(permInputLeft, 0, encDim);
        TripletZ2Vector[] sortedRightEnc = Arrays.copyOfRange(permInputRight, 0, encDim);
        if (isMalicious()) {
            // verify two input permutations is correct by comparing the sorted encoding
            TripletZ2Vector[] sortLeftEncUpper = new TripletZ2Vector[encDim];
            TripletZ2Vector[] sortLeftEncBelow = new TripletZ2Vector[encDim];
            TripletZ2Vector[] sortRightEncUpper = new TripletZ2Vector[encDim];
            TripletZ2Vector[] sortRightEncBelow = new TripletZ2Vector[encDim];
            for (int i = 0; i < encDim; i++) {
                sortLeftEncUpper[i] = sortedLeftEnc[i].reduceShiftRight(1);
                sortLeftEncBelow[i] = (TripletZ2Vector) sortedLeftEnc[i].copy();
                sortLeftEncBelow[i].reduce(sortLeftEncBelow[i].bitNum() - 1);
                sortRightEncUpper[i] = sortedRightEnc[i].reduceShiftRight(1);
                sortRightEncBelow[i] = (TripletZ2Vector) sortedRightEnc[i].copy();
                sortRightEncBelow[i].reduce(sortRightEncBelow[i].bitNum() - 1);
            }
            TripletZ2Vector leftCompRes = (TripletZ2Vector) z2IntegerCircuit.leq(sortLeftEncBelow, sortLeftEncUpper);
            TripletZ2Vector rightCompRes = (TripletZ2Vector) z2IntegerCircuit.leq(sortRightEncBelow, sortRightEncUpper);
            z2cParty.compareView4Zero(leftCompRes, rightCompRes);
        }
        return new TripletZ2Vector[][]{permInputLeft, permInputRight};
    }

    private int[] getPermutation(BitVector[] encoding) {
        BigInteger[] bigOut = ZlDatabase.create(envType, parallel, encoding).getBigIntegerData();
        HashSet<BigInteger> h = new HashSet<>(bigOut.length);
        for (BigInteger x : bigOut) {
            Preconditions.checkArgument(!h.contains(x));
            h.add(x);
        }
        return SortUtils.getPermutation(bigOut);
    }

    /**
     * generate the input for merge, and merge them
     *
     * @return merged [key, valid_flag, table_id, indexes], where valid_flag is not in the output if withDummy is false
     */
    private TripletZ2Vector[] mergeTables(TripletZ2Vector[] leftKey, TripletZ2Vector[] rightKey) throws MpcAbortException {
        MathPreconditions.checkEqual("leftKey.length", "rightKey.length", leftKey.length, rightKey.length);
        // input of merge alg should contain [key, valid_flag, table_id, indexes]
        TripletZ2Vector[] indexes = (TripletZ2Vector[]) z2cParty.setPublicValues(
            Z2VectorUtils.getBinaryIndex(leftNum + rightNum));
        List<TripletZ2Vector> leftInputList = new LinkedList<>();
        List<TripletZ2Vector> rightInputList = new LinkedList<>();
        for (int i = 0; i < leftKey.length; i++) {
            leftInputList.add(leftKey[i]);
            rightInputList.add(rightKey[i]);
        }
        leftInputList.add((TripletZ2Vector) z2cParty.setPublicValues(new BitVector[]{BitVectorFactory.createZeros(leftNum)})[0]);
        rightInputList.add((TripletZ2Vector) z2cParty.setPublicValues(new BitVector[]{BitVectorFactory.createOnes(rightNum)})[0]);
        IntStream.range(0, indexes.length).forEach(i -> {
            leftInputList.add(indexes[i].reduceShiftRight(rightNum));
            indexes[i].reduce(rightNum);
            rightInputList.add(indexes[i]);
        });
        return mergeParty.merge(leftInputList.toArray(TripletZ2Vector[]::new), rightInputList.toArray(TripletZ2Vector[]::new));
    }

    /**
     * permute the payload of the left table and get the equal flag
     */
    private TripletZ2Vector getEqFlag4RightTab(TripletZ2Vector[] mergeRes, int mergeKeyLen) throws MpcAbortException {
        // get the equal flag
        TripletZ2Vector[] upperInput = IntStream.range(0, mergeKeyLen)
            .mapToObj(i -> mergeRes[i].reduceShiftRight(1))
            .toArray(TripletZ2Vector[]::new);
        TripletZ2Vector[] belowInput = IntStream.range(0, mergeKeyLen)
            .mapToObj(i -> {
                TripletZ2Vector tmp = (TripletZ2Vector) mergeRes[i].copy();
                tmp.reduce(tmp.bitNum() - 1);
                return tmp;
            })
            .toArray(TripletZ2Vector[]::new);
        TripletZ2Vector eqFlag = (TripletZ2Vector) z2IntegerCircuit.eq(upperInput, belowInput);
        if (withDummy) {
            z2cParty.andi(eqFlag, mergeRes[mergeKeyLen].reduceShiftRight(1));
            mergeRes[mergeKeyLen].reduce(mergeRes[mergeKeyLen].bitNum() - 1);
            z2cParty.andi(eqFlag, mergeRes[mergeKeyLen]);
        }
        eqFlag.extendLength(leftNum + rightNum);

        // permute the payload of the left table
        int indexStartPos = mergeKeyLen + (withDummy ? 2 : 1);
        TripletZ2Vector[] perm = Arrays.copyOfRange(mergeRes, indexStartPos, mergeRes.length);
        // permute
        TripletZ2Vector permRes = permuteParty.applyInvPermutation(perm, new TripletZ2Vector[]{eqFlag})[0];
        permRes.reduce(rightNum);
        return permRes;
    }

}
