package edu.alibaba.mpc4j.crypto.fhe.seal.compatibility;

import edu.alibaba.mpc4j.crypto.fhe.seal.*;
import edu.alibaba.mpc4j.crypto.fhe.seal.context.EncryptionParameters;
import edu.alibaba.mpc4j.crypto.fhe.seal.context.SchemeType;
import edu.alibaba.mpc4j.crypto.fhe.seal.context.SealContext;
import edu.alibaba.mpc4j.crypto.fhe.seal.serialization.Serialization;
import org.bouncycastle.util.encoders.Hex;
import org.junit.Assert;
import org.junit.Test;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.Objects;

/**
 * tests for correctly reading BFV data generated by SEAL version 4.0.0.
 *
 * @author Weiran Liu
 * @date 2025/2/13
 */
public class SealBfvCompatibleTest {
    /**
     * SEAL data resource file path
     */
    private static final String SEAL_DATA_RESOURCE_FILE_PATH = "compatibility/";
    /**
     * SEAL BFV data resource file prefix:
     * 1 << 12 polynomial degree, 16-bit plaintext modulus, two 20-bit coefficient modulus.
     */
    private static final String SEAL_BFV_FILE_PREFIX = "bfv_4096_plain_16_coeff_20_20_";
    /**
     * SEAL data resource file suffix
     */
    private static final String SEAL_DATA_FILE_SUFFIX = ".txt";
    /**
     * BFV SEAL context
     */
    private final SealContext context;

    public SealBfvCompatibleTest() {
        // uint32_t poly_modulus_degree = 1 << 12;
        int poly_modulus_degree = 1 << 12;
        // EncryptionParameters params(scheme_type::bfv);
        EncryptionParameters params = new EncryptionParameters(SchemeType.BFV);
        // params.set_poly_modulus_degree(poly_modulus_degree);
        params.setPolyModulusDegree(poly_modulus_degree);
        // params.set_coeff_modulus(CoeffModulus::Create(poly_modulus_degree, {20, 20}));
        params.setCoeffModulus(new long[]{974849, 1032193});
        // params.set_plain_modulus(PlainModulus::Batching(poly_modulus_degree, 16));
        params.setPlainModulus(40961);
        // SEALContext context(params);
        context = new SealContext(params);
    }

    private byte[] loadHex(String filename) {
        // 打开对应的配置文件
        String sealBfvFileName = SEAL_DATA_RESOURCE_FILE_PATH + SEAL_BFV_FILE_PREFIX
            + filename + "_hex" + SEAL_DATA_FILE_SUFFIX;
        try {
            InputStream inputStream = Objects.requireNonNull(
                SealBfvCompatibleTest.class.getClassLoader().getResourceAsStream(sealBfvFileName)
            );
            InputStreamReader streamReader = new InputStreamReader(inputStream);
            BufferedReader bufferedReader = new BufferedReader(streamReader);
            return Hex.decode(bufferedReader.readLine());
        } catch (IOException e) {
            e.printStackTrace();
            throw new IllegalStateException("Failed to read SEAL BFV data: " + sealBfvFileName);
        }
    }

    private long[] loadData(String filename) {
        // 打开对应的配置文件
        String sealBfvFileName = SEAL_DATA_RESOURCE_FILE_PATH + SEAL_BFV_FILE_PREFIX
            + filename + "_data" + SEAL_DATA_FILE_SUFFIX;
        try {
            InputStream inputStream = Objects.requireNonNull(
                SealBfvCompatibleTest.class.getClassLoader().getResourceAsStream(sealBfvFileName)
            );
            InputStreamReader streamReader = new InputStreamReader(inputStream);
            BufferedReader bufferedReader = new BufferedReader(streamReader);
            return Arrays.stream(bufferedReader.readLine().split(" "))
                .mapToLong(Long::valueOf)
                .toArray();
        } catch (IOException e) {
            e.printStackTrace();
            throw new IllegalStateException("Failed to read SEAL BFV data: " + sealBfvFileName);
        }
    }

    @Test
    public void testSecretKey() throws IOException {
        String fileName = "secret_key";
        byte[] bytes = loadHex(fileName);
        long[] data = loadData(fileName);
        SecretKey secretKey = new SecretKey();
        Serialization.load(context, secretKey, bytes);
        Assert.assertArrayEquals(data, secretKey.data().data());
    }

    @Test
    public void testPublicKey() throws IOException {
        String fileName = "public_key";
        byte[] bytes = loadHex(fileName);
        long[] data = loadData(fileName);
        PublicKey publicKey = new PublicKey();
        Serialization.load(context, publicKey, bytes);
        Assert.assertArrayEquals(data, publicKey.data().data());
    }

    @Test
    public void testCiphertext() throws IOException {
        String fileName = "ciphertext";
        byte[] bytes = loadHex(fileName);
        long[] data = loadData(fileName);
        Ciphertext ciphertext = new Ciphertext();
        Serialization.load(context, ciphertext, bytes);
        Assert.assertArrayEquals(data, ciphertext.data());
    }

    @Test
    public void testSeedCiphertext() throws IOException {
        String fileName = "seed_ciphertext";
        byte[] bytes = loadHex(fileName);
        long[] data = loadData(fileName);
        Ciphertext ciphertext = new Ciphertext();
        // seed ciphertext uses different method to load
        ciphertext.load(context, bytes);
        Assert.assertArrayEquals(data, ciphertext.data());
    }

    @Test
    public void testRelinearizationKey() throws IOException {
        String fileName = "relinearization_key";
        byte[] bytes = loadHex(fileName);
        long[] data = loadData(fileName);
        RelinKeys relinKeys = new RelinKeys();
        Serialization.load(context, relinKeys, bytes);
        PublicKey[][] keys = relinKeys.data();
        long[] flattenData = Arrays.stream(keys)
            .map(key -> Arrays.stream(key).map(ki -> ki.data().data()).flatMapToLong(Arrays::stream).toArray())
            .flatMapToLong(Arrays::stream)
            .toArray();
        Assert.assertArrayEquals(data, flattenData);
    }

    @Test
    public void testGaloisKey() throws IOException {
        String fileName = "galois_key";
        byte[] bytes = loadHex(fileName);
        long[] data = loadData(fileName);
        GaloisKeys galoisKeys = new GaloisKeys();
        Serialization.load(context, galoisKeys, bytes);
        PublicKey[][] keys = galoisKeys.data();
        long[] flattenData = Arrays.stream(keys)
            .map(key -> Arrays.stream(key).map(ki -> ki.data().data()).flatMapToLong(Arrays::stream).toArray())
            .flatMapToLong(Arrays::stream)
            .toArray();
        Assert.assertArrayEquals(data, flattenData);
    }
}
